{% extends "base.html" %}

{% block title %}Hython!{% endblock %}

{% block slides %}
<!--



 -->
<div class="step" data-scale="5" data-x="0" data-y="0">
    <center>
        <h1><a href = 'http://git.io/hy' >Hy</a></h1>
        <h3>Lisp in Python</h3>
        <br />
        <b>Paul Tagliamonte</b>
        (<b><a href = 'http://twitter.com/paultag' >@paultag</a></b>)
    </center>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="0">
    Lisp is a pretty great language. (no, really!)
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="0" >
    It was one of the first high-level languages (like, ever)
</div>
<!--



 -->
<div class="step" data-x="5000" data-y="0" >
    I also really love Python. So much so, I don't really like using other
    languages, since I always write API bindings (for my own projects)
    in Python.
</div>
<!--



 -->
<div class="step" data-x="6500" data-y="0" >
    Thing is, I also really like Lisp (in particular, Clojure).
    It's a pretty neat language full of some powerful ideas. It's a language
    steeped in culture, and the de-facto language of AI.
</div>
<!--



 -->
<div class="step" data-x="8000" data-y="0" >
    So, might as well make them play nice, right?
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="8000" data-y="1000" >
    So, I just spent my winter break hacking on Hy.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="6500" data-y="1000" >
    Hy is a few things. It's a front-end "Lexer" (something that breaks
    the code apart) and also a back-end Python AST generator.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="5000" data-y="1000" >
    This means, I can (basically) convert Lisp expressions into
    Python.
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="1000" >
    Why Lisp?
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="1000" >
    It's fully-functional, extremely regular, &amp; simple. The language
    is made up of so-called "s-expressions".
    S-expressions look something like:<br />
    <div class = 'lisp'>(foo bar (baz foo))</div>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="1000" >
    Some folks (such as myself) prefer the "look" of Lisp-style
    languages, and it's commonly used in AI, so it's easier to "speak"
    Lisp for some things.<br />
    <br />
    Also, Macros. Sweet, sweet macros.
</div>
<!--



 -->
<div class="step" data-rotate="90" data-x="-1500" data-y="1000" >
    Before we go on, I should also note for the non-Lispers that in Lisp,
    everything's done in Polish notation &mdash; that is to say,
    <pre>1 + 1 + 2</pre> is written as
    <pre>+ 1 1 2</pre>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="2000" >
    If you were to write that in an s-expression, it'd look a bit like
    <div class = 'lisp' >(+ 1 1 2)</div>
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="0" data-y="3500" >
    <div class = 'repl' >(+ 1 1 2)</div>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="2000" >
    I also added lists and maps (dicts)
    <div class = 'lisp' >[1 2 3 4]</div>
<div class = 'lisp' >{key1 value1
 key2 value2}</div>
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="1500" data-y="3500" >
    <div class = 'repl' >(print [1 2 3 4 5])

(print {"one" "onekey"
        "two" "twokey"})</div>
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="2000" >
    You can even declare functions and stuff.
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="3000" data-y="3500" >
    <div class = 'repl' >(defn square-number [x]
  "This is a (valid!) docstring"
  (* x x))

(def foo 2)

; and, you call it, like so:
(print (square-number 3))</div>
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="5000" >
    I added support for for-loops (some academics may prefer recusion with
    TCO (tail call optimization), but Python has good for loops, so this
    ends up faster and easier on RAM.)
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="3000" data-y="6500" >
    <div class = 'repl' >(def my-list ["this" "is" "a" "test"])

(for [x my-list]
  (print x))
</div>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="5000" >
    Imports, and index access work too
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="1500" data-y="6500" >
    <div class = 'repl' >(import sys)

(print (index sys.argv 1))
</div>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="5000" >
  Code branching also works pretty well.
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="0" data-y="6500" >
    <div class = 'repl' >(if (== 1 2)
  (print "This is the 'true' branch")
  (print "This is the 'false' branch"))

    </div>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="8000" >
    And, now, for some of the advanced type stuff it can do (for the
    hardcore lispians)
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="0" data-y="9500" >
    <div class = 'repl' >(decorate-with foo (bar "baz")
  (defn my-function [arg1]
    " This is a decorated function "
    (kwapply (.method-name obj arg1) {"kwarg1" "kwval1"})))

(my-function "foo!")</div>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="8000" >
    Given the following code block:

<div class = 'lisp' >(def foo [1 2 3 4])
(print (index foo 100))  ; out of bounds</div>

    Even more magic, like proper tracebacks, totally work.

<div class = 'python' >Traceback (most recent call last)
  File "frob.hy", line 4, in module
    (print (index foo 100))  ; out of bounds
IndexError</div>
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="1500" data-y="9500" >
    Even imports (really!) work. Hy can import Python as if it were lisp, and
    Python can import Hy as if it were Python (after Hy is shimed in)
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="3000" data-y="9500" >
    Hy can do this via some newish magic, via
    <a href = 'http://www.python.org/dev/peps/pep-0302/' >PEP 302</a> and
    some clever hackery.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="4500" data-y="9500" >
    PEP 302 allows for "New Import Hooks", which basically were intended to
    be used to search non-standard places (like the Internet, in one example)
    if the module isn't on the Python path.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="6000" data-y="9500" >
    Baiscally, my
    <a href = 'https://github.com/paultag/hy/blob/master/hy/lang/importer.py#L19' >meta-importer</a>
    (as it's called) just searches the normal
    sys.path for modules and packages ending with .hy, just like the
    built-in stuff searches for .py (or .pyc, etc). The loader-class is then
    appended to sys.meta_path.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="7500" data-y="9500" >
    If it finds a .hy file, the lexer and AST translation routine(s) kick in,
    and insert a completely fake AST into sys.modules, then returns it back
    out.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="9000" data-y="9500" >
    Which is, yes, amazing. PEP 302 is pretty much the coolest thing, like,
    ever.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="10500" data-y="9500" >
    The importer consists of two parts, the Importer and the Finder.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="12000" data-y="9500" >
    The finder is in charge of finding the file to import, and returns
    a Loader object that is able to load that file into sys.modules. The
    function looks a bit like:
    <div class = 'python' >finder.find_module(fullname, path=None)</div>
    where "fullname" is something like <code>os.path</code>
</div>
<!--



 -->
<div class="step" data-x="12000" data-y="10000" >
    The Loader object (which the finder returned up above) can be then invoked
    and is expected to have the following signature:
    <div class = 'python' >loader.load_module(fullname)</div>
    (where "fullname" is again, something like <code>os.path</code>)
</div>
<!--



 -->
<div class="step" data-x="10500" data-y="10000" >
The importer basically looks like:
    <div class = 'python' >class MetaImporter(HyFinder):
    def find_module(self, fullname, path=None):
        pth = self.find_on_path(fullname)
        if pth is None:
            return
        return MetaLoader()
    </div>
And the finder basically looks like:
<div class = 'python' >class MetaLoader(HyFinder):
    def load_module(self, fullname):
        # [snip]
        mod = _hy_import_file(pth, fullname)
        ispkg = self.is_package(fullname)
        mod.__file__ = pth
        mod.__loader__ = self
        mod.__name__ = fullname
        if ispkg:
            mod.__path__ = []
            mod.__package__ = fullname
        else:
            mod.__package__ = fullname.rpartition('.')[0]
        sys.modules[fullname] = mod
        return mod
</div>
</div>
<!--



 -->
<div class="step" data-x="9000" data-y="10000" >
   But, wait! Paul! You totally glossed over the AST stuff! Talk more about
   that!
</div>
<!--



 -->
<div class="step" data-x="7500" data-y="10000" >
    ASTs (or Abstract Syntax Trees) are the <i>internal</i> representation
    if Python code.
</div>
<!--



 -->
<div class="step" data-x="6000" data-y="10000" >
    They can get pretty fugly, but they're extremely powerful. Basically, this
    means that Python (like Lisp before it, for the record) can
    <b>programmatically</b> alter itself.
</div>
<!--



 -->
<div class="step" data-x="4500" data-y="10000" >
Given the following Python:
<div class = 'python' >def hello_world(x):
    print "Hello,", x</div>
We get the following AST:
<div class = 'python' >FunctionDef(
    name='hello_world',
    args=arguments(args=[Name(id='x', ctx=Param())],
        vararg=None, kwarg=None, defaults=[]),
    body=[
        Print(dest=None, values=[Str(s='Hello,'),
            Name(id='x', ctx=Load())], nl=True)
    ],
    decorator_list=[])</div>
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="10000" >
    Baiscally, Hy acts as an AST "compiler" just takes the parsed &amp;
    lexed Lisp, and "renders" it out to a Python AST.
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="10000" >
    To demystify some of what Hy is doing, let's take the following Hython
    (lisp) expression:
<div class = 'lisp' >(defn hello-world [x]
  (print "Hello," x))</div>

And check out the generated AST back in Python-land.

<div class = 'python' >FunctionDef(
    name='hello_world',
    args=arguments(args=[Name(id='x', ctx=Param())],
        vararg=None, kwarg=None, defaults=[]),
    body=[
        Print(dest=None, values=[Str(s='Hello,'),
            Name(id='x', ctx=Load())], nl=True)
    ],
    decorator_list=[])</div>
(hint: It's the same as that last slide!)
</div>
<!--



-->
<div class="step" data-x="0" data-y="10000" >
    Alright, so we've got ASTs, let's check out how the internals of Hy work
    to generate the AST from Lexed Lisp
</div>
<!--



-->
<div class="step" data-x="0" data-y="11000" >
    Basically, hy internal Lexed Objects (stuff like HYExpression, HYString,
    HYBool, HYList, etc) get passed to Hy's AST Generator's "render" method,
    and get passed to one of a few methods depending on it's type. (helps
    keep things clear and neat, well, as neat as they can be).
</div>
<!--



-->
<div class="step" data-x="1000" data-y="11000" >
    Let's start simple -- the String generator:
    <div class = 'python' >
# [snip]
import ast
# [snip]
    def render_string(self, node):
        # (node is a string, in this case)
        return ast.Str(s=str(node))
# [snip]
    </div>
    Which produces (when given "foo!") the following block:
    <div class = 'python' >Str(s='foo!')</div>
</div>
<!--



-->
<div class="step" data-x="2000" data-y="11000" >
    OK, let's get more advanced here, the List render-er.
    <div class = 'python' >
# [snip]
import ast
# [snip]
    def render_list(self, node):
        ret = []
        for c in node:
            ret.append(self.render(c))
        return ast.List(elts=ret, ctx=ast.Load())
# [snip]
    </div>
    Which produces (when given <code>[1, 2, "foo"]</code>) the following block:
    <div class = 'python' >List(elts=[Num(n=1), Num(n=2), Str(s='foo')], ctx=Load())</div>
</div>
<!--



-->
<div class="step" data-x="3000" data-y="11000" >
    Alright, let's move up to Dicts (slighty more hackey)
    <div class = 'python' >
    def render_map(self, node):
        keys = []
        values = []
        for key in node:
            keys.append(self.render(key))
            values.append(self.render(node[key]))
        return ast.Dict(keys=keys, values=values)
    </div>
    Which produces (when given <code>{"one": "oneval", "two": "twoval"}</code>)
    the following block:
    <div class = 'python' >Dict(
    keys=[Str(s='one'), Str(s='two')],
    values=[Str(s='oneval'), Str(s='twoval')]
)</div>
</div>
<!--



-->
<div class="step" data-x="4000" data-y="11000" >
    Now, here's the Symbol generator:
    <div class = 'python' >
    def render_symbol(self, node):
        # (node is a string, in this case)
        if "." in node:
            glob, local = node.rsplit(".", 1)
            ret = ast.Attribute(
                value=self.render_symbol(glob),
                attr=str(local),
                ctx=ast.Load()
            )
            return ret
        return ast.Name(id=str(node), ctx=ast.Load())
    </div>
    It produces something like (for "foo"):
    <div class = 'python' >Name(id='foo', ctx=Load())</div>
    Or (for "foo.bar"):
    <div class = 'python' >Attribute(value=Name(id='foo', ctx=Load()),
    attr='bar', ctx=Load())</div>
</div>
<!--



-->
<div class="step" data-x="5000" data-y="11000" >
    In addition to the basics, we also need to render expressions (function
    calls, etc), and friends.
</div>
<!--



-->
<div class="step" data-rotate="180" data-x="5000" data-y="12000" >
    <div class = 'python' >def render_expression(self, node):
        # node is a list, like ['fn', 'arg', 'arg', 'arg']

        inv = node.get_invocation()
        if inv['function'] in self.native_cases:
            return self.native_cases[inv['function']](node)

        for key in self.startswith:
            if inv['function'].startswith(key):
                return self.startswith[key](node)

        c = []
        for child in node.get_children():
            c.append(self.render(child))

        if inv['function'] in special_cases:
            return special_cases[inv['function']](node, c, self)

        ret = value=ast.Call(
                func=self.render_symbol(inv['function']),
                args=c,
                keywords=[],
                starargs=None,
                kwargs=None
        )
        return ret</div>
</div>
<!--



-->
<div class="step" data-rotate="180" data-x="4000" data-y="12000" >
    Defining a function
<div class = 'python' >
    def _defn(self, node):
        inv = node.get_invocation()
        args = inv['args']
        name = args.pop(0)
        sig = args.pop(0)
        doc = None
        for child in args:
            c.append(self.render(child))
        cont = c[-1]
        body = cont if isinstance(cont, list) else [cont]
        ret = ast.FunctionDef(
            name=str(name),
            args=ast.arguments(
                args=[
                    ast.Name(arg=str(x), id=str(x), ctx=ast.Param()) for x in sig
                ],
                vararg=None,
                kwarg=None,
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]
            ),
            body=body,
            decorator_list=[])
        return ret
    </div>
</div>
<!--



-->
<div class="step" data-rotate="180" data-x="3000" data-y="12000" >
    Now, let's go back and look at another bit of generated
    AST off Lisp -- let's look at:
<div class = 'python' >def square(number):
    return number * number</div>

    Which produces this:
    <div class = 'python' >
FunctionDef(
    name='square',
    args=arguments(
        args=[Name(id='number', ctx=Param())],
        vararg=None,
        kwarg=None,
        defaults=[]
    ),
    body=[
        Return(
            value=BinOp(
                left=Name(id='number', ctx=Load()),
                op=Mult(),
                right=Name(id='number', ctx=Load())
            )
        )
    ],
    decorator_list=[]
)
    </div>
</div>
<!--



-->
<div class="step" data-rotate="180" data-x="2000" data-y="12000" >
    Now, for how that decorator magic works:
    (remember, a FunctionDef looks like:)
    <div class = 'python' >ast.FunctionDef(
    name=str(name),
    args=ast.arguments(
        # [snip]
    ),
    body=body,
    decorator_list=[]
)
    </div>

So, our decorate "macro" in Python does the following:

    <div class = 'python' >
    def _ast_decorate(self, node):
        i = node.get_invocation()
        c = i['args']
        meth = c.pop(-1)
        fn = self.render(meth)
        for child in c:
            fn.decorator_list.append(self.render(child))
        return fn
    </div>
</div>
<!--



-->
<div class="step" data-rotate="180" data-x="1000" data-y="12000" >
    Phew! Ok, that was a lot. Before I show you some stuff on the Terminal,
    are there any questions on ASTs or how Hy is generating some of these
    Pythonic objects?
</div>

{#
<!--



-->
<div class="step" data-scale="10" data-x="0" data-y="0" >
</div>
#}

{% endblock %}
