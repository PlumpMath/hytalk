{% extends "base.html" %}

{% block title %}Hython!{% endblock %}

{% block slides %}
<!--



 -->
<div class="step" data-scale="5" data-x="0" data-y="0">
    <center>
        <h1><a href = 'http://git.io/hy' >Hy</a></h1>
        <h3>Lisp in Python</h3>
        <br />
        <b>Paul Tagliamonte</b>
        (<b><a href = 'http://twitter.com/paultag' >@paultag</a></b>)
    </center>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="0">
    Lisp is a pretty great language. (Really!)
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="0" >
    It was one of the first high-level languages (like, ever)
</div>
<!--



 -->
<div class="step" data-x="5000" data-y="0" >
    I really love Python. So much so, I don't really like using other
    languages, since I always write API bindings (for my own projects)
    in Python.
</div>
<!--



 -->
<div class="step" data-x="6500" data-y="0" >
    Thing is, I also really like Lisp. It's a pretty neat language.
</div>
<!--



 -->
<div class="step" data-x="8000" data-y="0" >
    So, might as well make them play nice, right?
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="8000" data-y="1000" >
    So, I just spent my winter break hacking on Hy.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="6500" data-y="1000" >
    Hy is a few things. It's a front-end "Lexer" (something that breaks
    the code apart) and also a back-end Python AST generator.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="5000" data-y="1000" >
    This means, I can (basically) convert Lisp expressions into
    Python.
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="1000" >
    So, why Lisp?
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="1000" >
    It's fully-functional, extremely regular, &amp; simple. The language
    is made up of so-called "s-expressions".
    S-expressions look something like:<br />
    <div class = 'lisp'>(foo bar (baz foo))</div>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="1000" >
    Some folks (such as myself) prefer the "look" of Lisp-style
    languages, and it's commonly used in AI, so it's easier to "speak"
    Lisp for some things.<br />
    <br />
    Also, Macros. Sweet, sweet macros.
</div>
<!--



 -->
<div class="step" data-rotate="90" data-x="-1500" data-y="1000" >
    I should also note that in Lisp, everything's done in Polish
    notation (that is to say,
    <pre>1 + 1 + 2</pre> is written as
    <pre>+ 1 1 2</pre>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="2000" >
    If you were to write that in an s-expression, it'd look a bit like
    <div class = 'lisp' >(+ 1 1 2)</div>
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="0" data-y="3500" >
    <div class = 'repl' >(+ 1 1 2)</div>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="2000" >
    I also added lists and maps (dicts)
    <div class = 'lisp' >[1 2 3 4]</div>
<div class = 'lisp' >{key1 value1
 key2 value2}</div>
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="1500" data-y="3500" >
    <div class = 'repl' >(print [1 2 3 4 5])

(print {"one" "onekey"
        "two" "twokey"})</div>
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="2000" >
    You can even declare functions and stuff.
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="3000" data-y="3500" >
    <div class = 'repl' >(defn square-number [x]
  "This is a (valid!) docstring"
  (* x x))

; and, you call it, like so:
(print (square-number 3))</div>
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="5000" >
    I added support for for-loops
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="3000" data-y="6500" >
    <div class = 'repl' >(def my-list ["this" "is" "a" "test"])

(for [x my-list]
  (print x))
</div>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="5000" >
    Imports, and index access work too
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="1500" data-y="6500" >
    <div class = 'repl' >(import sys)

(print (index sys.argv 1))
</div>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="5000" >
  Code branching also works pretty well.
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="0" data-y="6500" >
    <div class = 'repl' >(if (== 1 2)
  (print "This is the 'true' branch")
  (print "This is the 'false' branch"))

    </div>
</div>
<!--



 -->
<div class="step" data-x="0" data-y="8000" >
    And, now, for some of the advanced type stuff it can do:
</div>
<!--



 -->
<div class="step wide-step" data-rotate="180" data-x="0" data-y="9500" >
    <div class = 'repl' >(decorate-with foo (bar "baz")
  (defn my-function [arg1]
    " This is a decorated function "
    (kwapply (.method-name obj arg1) {"kwarg1" "kwval1"})))

(my-function "foo!")</div>
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="8000" >
    Given the following code block:

<div class = 'lisp' >(def foo [1 2 3 4])
(print (index foo 100))  ; out of bounds</div>

    Even more magic, like proper tracebacks, totally work.

<div class = 'python' >Traceback (most recent call last)
  File "frob.hy", line 4, in module
    (print (index foo 100))  ; out of bounds
IndexError</div>
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="1500" data-y="9500" >
    Even imports (really!) work. Hy can import Python as if it were lisp, and
    Python can import Hy as if it were Python.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="3000" data-y="9500" >
    Hy can do this via some newish magic, via
    <a href = 'http://www.python.org/dev/peps/pep-0302/' >PEP 302</a> and
    some clever hackery.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="4500" data-y="9500" >
    PEP 302 allows for "New Import Hooks", which basically were intended to
    be used to search non-standard places (like the Internet, in one example)
    if the module isn't on the Python path.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="6000" data-y="9500" >
    Baiscally, my
    <a href = 'https://github.com/paultag/hy/blob/master/hy/lang/importer.py#L19' >meta-importer</a>
    (as it's called) just searches the normal
    sys.path for modules and packages ending with .hy, just like the
    built-in stuff searches for .py (or .pyc, etc). The loader-class is then
    appended to sys.meta_path.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="7500" data-y="9500" >
    If it finds a .hy file, the lexer and AST translation routine(s) kick in,
    and insert a completely fake AST into sys.modules, then returns it back
    out.
</div>
<!--



 -->
<div class="step" data-rotate="180" data-x="9000" data-y="9500" >
    Which is, yes, amazing. PEP 302 is pretty much the coolest thing, like,
    ever.
</div>
<!--



 -->
<div class="step" data-x="9000" data-y="10000" >
   But, wait! Paul! You totally glossed over the AST stuff! Talk more about
   that!
</div>
<!--



 -->
<div class="step" data-x="7500" data-y="10000" >
    ASTs (or Abstract Syntax Trees) are the <i>internal</i> representation
    if Python code.
</div>
<!--



 -->
<div class="step" data-x="6000" data-y="10000" >
    They can get pretty fugly, but they're extremely powerful. Basically, this
    means that Python (like Lisp before it, for the record) can
    <b>programmatically</b> alter itself.
</div>
<!--



 -->
<div class="step" data-x="4500" data-y="10000" >
Given the following Python:
<div class = 'python' >def hello_world(x):
    print "Hello,", x</div>
We get the following AST:
<div class = 'python' >FunctionDef(
    name='hello_world',
    args=arguments(args=[Name(id='x', ctx=Param())],
        vararg=None, kwarg=None, defaults=[]),
    body=[
        Print(dest=None, values=[Str(s='Hello,'),
            Name(id='x', ctx=Load())], nl=True)
    ],
    decorator_list=[])</div>
</div>
<!--



 -->
<div class="step" data-x="3000" data-y="10000" >
    Baiscally, my AST "compiler" just takes my parsed &amp; lexed Lisp,
    and "renders" it out to a Python AST.
</div>
<!--



 -->
<div class="step" data-x="1500" data-y="10000" >
    So, given the following Hython:
<div class = 'lisp' >(defn hello-world [x]
  (print "Hello," x))</div>

Hy produced the following Python AST:

<div class = 'python' >FunctionDef(
    name='hello_world',
    args=arguments(args=[Name(id='x', ctx=Param())],
        vararg=None, kwarg=None, defaults=[]),
    body=[
        Print(dest=None, values=[Str(s='Hello,'),
            Name(id='x', ctx=Load())], nl=True)
    ],
    decorator_list=[])</div>
(hint: It's the same!)
</div>
<!--



 -->
<div class="step" data-x="0" data-y="10000" >
   <a href = 'https://github.com/paultag/hy/blob/master/hy/compiler/ast27.py' >The AST Generation code</a>
   (warning, it's very very very ugly) (basically) consists of lots of special-cases,
   and a few clever hacks to get the AST into a form Python can properly evaluate.
</div>
<!--



 -->
<div class="step" data-x="0" data-y="11500" >
    Now, for my twist ending:<br />
    <br />
    The flask app running backend for these slides (color bits, repl) is totally
    implemented in Hy.<br />
    <br />
    Yes, that's right. <i>awesome.</i>
</div>


{#
<!--



-->
<div class="step" data-scale="10" data-x="0" data-y="0" >
</div>
#}

{% endblock %}
